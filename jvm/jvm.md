

# jvm内存结构

## 运行时方法区

### 运行时方法区对象内存分布图

![image-20210526170105160](../assert/image-20210526170105160.png)



## 执行引擎

### 执行引擎作用

jvm将字节码装载在其内部，但是操作系统不能直接识别字节码，这就需要**执行引擎将字节码指令解释/编译为对应平台上的本地机器指令——即将高级语言翻译为机器语言**

![image-20210526170255127](../assert/image-20210526170255127.png)



### 执行引擎结构

![image-20210526171415111](../assert/image-20210526171415111.png)

![image-20210526171009673](../assert/image-20210526171009673.png)



<font color="#FF0000" size="5">主要来说就是jvm执行引擎既有解释器(interpreter)也有编译器(jit compiler)</font>



![image-20210526171040925](../assert/image-20210526171040925.png)

![image-20210526172345676](../assert/image-20210526172345676.png)

![image-20210526190546983](../assert/image-20210526190546983.png)



什么是字节码？

![image-20210526173733617](../assert/image-20210526173824650.png)



### 解释器和JIT

当虚拟机启动时候，**解释器可以首先发挥作用**，不用等待jit编译器全部编译完成再执行，这样可以省去许多不必要的编译时间。并且随着程序运行时间的推移，jit编译器逐渐发挥作用，根据热点探测功能，**将有价值的字节码编译为本地机器指令（热点代码），并缓存**，来得到更高的程序执行效率

  ![image-20210526192211499](../assert/image-20210526192211499.png)

### JIT

热点代码会触发JIT  （方法调用计数器和回边计数器）

<center>热点判断</center>

![image-20210526200023916](../assert/image-20210526200023916.png)





<center>方法调用计数器</center>



![image-20210526201001222](../assert/image-20210526201001222.png)

![image-20210526200154602](../assert/image-20210526200154602.png)



<center>回边计数器</center>

![image-20210526201235103](../assert/image-20210526201235103.png)

 ![image-20210526201332937](../assert/image-20210526201332937.png)





<center>热度衰减</center>

假如只数绝对次数，那么只要执行时间够久，所有代码都能成为热点代码，如何改善

![image-20210526200719439](../assert/image-20210526200719439.png)



<center><font size=10>c1 c2编译器</font></center>

![image-20210526201717181](../assert/image-20210526201717181.png)

![image-20210526201957771](../assert/image-20210526201957771.png)

<img src="../assert/image-20210526202123970.png" alt="image-20210526202123970" style="zoom:67%;" />

总结：

- 一般来讲，jit编译出来的机器码性能比解释器高
- C2编译器启动时长比C1编译器慢，系统稳定执行后，C2编译器速度远远快于C1编译器







## String table

![image-20210526105522633](../assert/image-20210526105522633.png)

s1: "a"放入常量池

s2:"b"放入常量池

s3:"ab"放入常量池  （编译优化，直接在编译阶段把”a“+"b"编译为"ab"）

s4: new Stringbuffer,用append方法拼接”a“ ”b“，最后toString，相当于重新new了一个String对象，放在堆中

s5:常量池已经有"ab" 直接引用

s6:尝试把s4（”ab“）放入常量池，常量池中已有"ab"，所以放入失败，直接返回常量池中对象给s6



s3==s4? :  s3是常量池中“ab”，s4是new的string对象，结果为false

s3==s5? : s3是常量池中“ab”，s5企图把"ab"放入常量池，但常量池已有，直接引用常量池中对象，所以结果为true

s3==s6? :  s3是常量池中“ab”;尝试试把s4（”ab“）放入常量池，常量池中已有"ab"，所以放入失败，直接返回常量池中对象给s6  ;所以为true



x1==x2?: 当前的话是new个x2，然后成功把x2放入常量池，然后x1直接引用常量池对象，结果为true

​				如果x2.intern();和String x1="cd"；交换位置  ，那么在String x1="cd"时把cd放入常量池，而x2.intern();由于常量池中已有cd，不会成功把x2放入常量池，所以x1==x2为false；

![image-20210528111950009](../assert/image-20210528111950009.png)

![image-20210528112535490](../assert/image-20210528112535490.png)



**jdk1.6和jdk1.8的intern的区别：**（String s6=s4.intern() 区别在于若常量池中没有，1.8会在常量池中创建一个引用，直接指向s4，而1.6是复制一份字面量放入池中）

![image-20210528113140825](../assert/image-20210528113140825.png)

jdk1.6：![image-20210528112713386](../assert/image-20210528112713386.png)



jdk1.8：

![image-20210528113209455](../assert/image-20210528113209455.png)



**总结：** 

1.直接用String s=”xxx“ 是在常量池中放”xxx“ s引用指向这个池子；如果下次还有同样的”xxx“，那么不会重复入池；如果是String x=new String（”xxx“），那么是在堆中放一个新对象，和池子无关；string.intern（）尝试把string内容放入池子（jdk1.6和1.8有区别）；

2.string x=”xxx“+x1 其实是新建了一个stringbuilder然后append，最后tostring（tostring最后调用了一个newstring,**注意append（）等最后调用tostring的方法，不会再常量池中放入字符**） 那么显然这个x也是一个堆中新对象

3.**字符串拼接不一定都用stringbuilder，如果拼接符号左右两边都是字符串常量或者常量引用，则仍然使用编译器优化 即非stringBuilder  **

![image-20210526220528438](../assert/image-20210526220528438.png)

4.节省空间，多用字面量赋值，少用new string，用newstring的话尽量用intern ()



## 其他知识

### 机器码 指令 汇编

计算机只认识机器语言，机器语言可读性实在太差，所以发明了指令，把机器码中特定的0和1序列简化为对应指令（比如mov，inc）

![image-20210526173251584](../assert/image-20210526173251584.png)

指令可读性还是太差，所以发明了汇编语言

![image-20210526173347375](../assert/image-20210526173347375.png)

最后为了让人编程更方便 发明了高级语言

![image-20210526173412760](../assert/image-20210526173412760.png)

![image-20210526173458022](../assert/image-20210526173458022.png)

java中特有的字节码，执行引擎就是转译为可执行的指令

![image-20210526173733617](../assert/image-20210526173733617.png)

# 垃圾回收

## 垃圾标记算法

当一个对象已经不再被任何的存活对象继续引用时，就宣判为死亡

判断对象存活一般有两种方式：**引用计数算法（java里不用！！）**和**可达性算法**

### 引用计数算法

java没有选择引用计数算法，因为他无法处理循环引用情况

![image-20210528194243951](../assert/image-20210528194243951.png)

![image-20210528194410070](../assert/image-20210528194410070.png)

### 可达性分析算法

![image-20210528194952536](../assert/image-20210528194952536.png)

![image-20210528194914616](../assert/image-20210528194914616.png)

![image-20210528195126262](../assert/image-20210528195126262.png)

![image-20210528195549391](../assert/image-20210528195549391.png)

### finalization机制

![image-20210528200001610](../assert/image-20210528200001610.png)

![image-20210528200023958](../assert/image-20210528200023958.png)

对象的三种可能状态：

![image-20210528200241965](../assert/image-20210528200241965.png)

![image-20210528200516726](../assert/image-20210528200516726.png)

## 垃圾清除算法

### 标记清除算法

![image-20210529190232135](../assert/image-20210529190232135.png)

![image-20210529190247908](../assert/image-20210529190247908.png)

![image-20210529190321542](../assert/image-20210529190321542.png)



### 复制算法

![image-20210529191310966](../assert/image-20210529191310966.png)

![image-20210529191319198](../assert/image-20210529191319198.png)

![image-20210529191607836](../assert/image-20210529191607836.png)

![image-20210529191629667](../assert/image-20210529191629667.png)

### 标记压缩算法

![image-20210529191708970](../assert/image-20210529191708970.png)

![image-20210529191718810](../assert/image-20210529191718810.png)

![image-20210529191739674](../assert/image-20210529191739674.png)

![image-20210529192113450](../assert/image-20210529192113450.png)

### 上面三种算法对比

![image-20210529192400642](../assert/image-20210529192400642.png)

### 分代收集算法

![image-20210529192853810](../assert/image-20210529192853810.png)

![image-20210529192904922](../assert/image-20210529192904922.png)

![image-20210529193016646](../assert/image-20210529193016646.png)

  ### 增量收集算法

![image-20210529193431907](../assert/image-20210529193431907.png)

![image-20210529193453470](../assert/image-20210529193453470.png)

### 分区算法

![image-20210529193524560](../assert/image-20210529193524560.png)

![image-20210529193632655](../assert/image-20210529193632655.png)

## 垃圾回收相关概念

### System.gc()

![image-20210529200032169](../assert/image-20210529200032169.png)

### 内存溢出OOM



![image-20210529201033120](../assert/image-20210529201033120.png)

![image-20210529201259073](../assert/image-20210529201259073.png)

![image-20210529201344265](../assert/image-20210529201344265.png)

### 内存泄漏

![image-20210529201422883](../assert/image-20210529201422883.png)

![image-20210529202253901](../assert/image-20210529202253901.png)

### Stop-the-world

![image-20210529202852580](../assert/image-20210529202852580.png)

![image-20210529202913068](../assert/image-20210529202913068.png)

### 垃圾回收的并行与并发



![image-20210529203117150](../assert/image-20210529203117150.png)

![image-20210529203321827](../assert/image-20210529203321827.png)

### 安全点和安全区

安全点：

![image-20210529203647323](../assert/image-20210529203647323.png)

![image-20210529203619521](../assert/image-20210529203619521.png)



安全区：

![image-20210529203753846](../assert/image-20210529203753846.png)

![image-20210529203947011](../assert/image-20210529203947011.png)

# java中引用

强软弱虚引用

强引用：只要有引用关系，就不会回收

软引用：内存不足或者**紧张**才回收

弱引用：发现即回收 ，GC总是回收弱引用

虚引用：基本没用，没影响，也不能用它拿到引用的类。随时回收。唯一的目的是跟踪垃圾回收过程，在对象被回收时收到一个系统通知。配合引用队列使用，在对象被回收后，把对象放到引用队列。

 ![image-20210530154704347](../assert/image-20210530154704347.png)

## 强引用

![image-20210530154950540](../assert/image-20210530154950540.png)

## 软引用

![image-20210530155548567](../assert/image-20210530155548567.png)

![image-20210530155814213](../assert/image-20210530155814213.png)

## 弱引用

![image-20210530160300748](../assert/image-20210530160300748.png)

  ![image-20210530160355817](../assert/image-20210530160355817.png)

weakhashmap：用于缓存，及时回收



## 虚引用

![image-20210530160645709](../assert/image-20210530160645709.png)

![image-20210530160842578](../assert/image-20210530160842578.png)

  ## 终结器引用

![image-20210530161333662](../assert/image-20210530161333662.png)



# 垃圾回收器GC

按线程数分 串行回收器和并行回收器

按碎片处理方式分：压缩式垃圾回收器和非压缩式回收器

按工作内存区间分：年轻代回收器和老年代回收器

![image-20210530180839925](../assert/image-20210530180839925.png)

![image-20210530181619299](../assert/image-20210530181619299.png)



## 评估gc的性能指标

![image-20210530163744816](../assert/image-20210530163744816.png)

吞吐量、暂停时间和内存占用三者构成不可能三角

![image-20210530164011959](../assert/image-20210530164011959.png)

吞吐量和暂停时间指标对比：

吞吐量：

![image-20210530164351230](../assert/image-20210530164351230.png)

暂停时间：

![image-20210530164418937](../assert/image-20210530164418937.png)



![image-20210530164535533](../assert/image-20210530164535533.png)

![image-20210530164548151](../assert/image-20210530164548151.png)

## 垃圾收集器组合关系

![image-20210530181711241](../assert/image-20210530181711241.png)

 ![image-20210530182119429](../assert/image-20210530182119429.png)

![image-20210530182153729](../assert/image-20210530182153729.png)

## Serial和Serila old回收器 

串行回收

![image-20210530182552150](../assert/image-20210530182552150.png)



![image-20210530182813384](../assert/image-20210530182813384.png)

![image-20210530182943009](../assert/image-20210530182943009.png)

![image-20210530183057101](../assert/image-20210530183057101.png)

## ParNew回收器

并行回收

配合serialold使用

![image-20210530183126514](../assert/image-20210530183126514.png)

![image-20210530183343799](../assert/image-20210530183343799.png)



![image-20210530183423140](../assert/image-20210530183423140.png)



## Parallel Scavenge和Parallel Scavenge old回收器

吞吐量优先 适合人机交互少的后台运行场景

![image-20210530183549622](../assert/image-20210530183549622.png)

![image-20210530183813918](../assert/image-20210530183813918.png)

![image-20210530183937153](../assert/image-20210530183937153.png)

![image-20210530183945842](../assert/image-20210530183945842.png)



## CMS回收器

低延迟 适合交互场景

![image-20210530191559572](../assert/image-20210530191559572.png)

![image-20210530191749522](../assert/image-20210530191749522.png)

![image-20210530191830674](../assert/image-20210530191830674.png)、

![image-20210530191914484](../assert/image-20210530191914484.png)、![image-20210530192040096](../assert/image-20210530192040096.png)

![image-20210530193640815](../assert/image-20210530193640815.png)

![image-20210530193906551](../assert/image-20210530193906551.png)

**因为在并发执行的时候要进行gc，而标记压缩算法要更改可达对象的地址，这不可取**

![image-20210530194004502](../assert/image-20210530194004502.png)

CMS优缺点

![image-20210530194125026](../assert/image-20210530194125026.png) 

![image-20210530194843517](../assert/image-20210530194843517.png)



## 对以上垃圾回收器的总结

![image-20210530194752230](../assert/image-20210530194752230.png)

## G1回收器

区域化分代式

![image-20210530195005216](../assert/image-20210530195005216.png)

![image-20210530200559612](../assert/image-20210530200559612.png)

![image-20210530200631587](../assert/image-20210530200631587.png)



**G1的优势**

![image-20210530200841759](../assert/image-20210530200841759.png)

![image-20210530201224671](../assert/image-20210530201224671.png)

![image-20210530201338855](../assert/image-20210530201338855.png)



![image-20210530201157433](../assert/image-20210530201157433.png)

<img src="../assert/image-20210530203306232.png" alt="image-20210530203306232" style="zoom:67%;" />



**G1缺点**

![image-20210530202100626](../assert/image-20210530202100626.png)



**G1相关参数**

![image-20210530202221786](../assert/image-20210530202221786.png)

![image-20210530202710391](../assert/image-20210530202710391.png)



**G1使用场景**

![image-20210530202748760](../assert/image-20210530202748760.png)



## G1回收器垃圾回收过程

![image-20210530203705482](../assert/image-20210530203705482.png)

![image-20210530203754166](../assert/image-20210530203754166.png)

![image-20210530204001517](../assert/image-20210530204001517.png)

**记忆集和屏障**

![image-20210530204244369](../assert/image-20210530204244369.png)

![image-20210530204508401](../assert/image-20210530204508401.png)



**1.youngGC**

![image-20210530204800276](../assert/image-20210530204800276.png)

![image-20210530204913730](../assert/image-20210530204913730.png)

![image-20210530205119910](../assert/image-20210530205119910.png)

![image-20210530204902025](../assert/image-20210530204902025.png)



**2.并发标记过程**

![image-20210530205251056](../assert/image-20210530205251056.png)

 

**3.混合回收**

![image-20210530205520306](../assert/image-20210530205520306.png)

![image-20210530205614088](../assert/image-20210530205614088.png)



**4.full gc（不一定出现）**

![image-20210530205802424](../assert/image-20210530205802424.png)





![image-20210530205943951](../assert/image-20210530205943951.png)



## 七款垃圾回收器总结对比抉择

![image-20210530210055471](../assert/image-20210530210055471.png)

![image-20210530210223721](../assert/image-20210530210223721.png)

![image-20210530210324955](../assert/image-20210530210324955.png)

  