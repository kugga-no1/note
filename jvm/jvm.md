

# jvm内存结构

## 运行时方法区

### 运行时方法区对象内存分布图

![image-20210526170105160](../assert/image-20210526170105160.png)



## 执行引擎

### 执行引擎作用

jvm将字节码装载在其内部，但是操作系统不能直接识别字节码，这就需要**执行引擎将字节码指令解释/编译为对应平台上的本地机器指令——即将高级语言翻译为机器语言**

![image-20210526170255127](../assert/image-20210526170255127.png)



### 执行引擎结构

![image-20210526171415111](../assert/image-20210526171415111.png)

![image-20210526171009673](../assert/image-20210526171009673.png)



<font color="#FF0000" size="5">主要来说就是jvm执行引擎既有解释器(interpreter)也有编译器(jit compiler)</font>



![image-20210526171040925](../assert/image-20210526171040925.png)

![image-20210526172345676](../assert/image-20210526172345676.png)

![image-20210526190546983](../assert/image-20210526190546983.png)



什么是字节码？

![image-20210526173733617](../assert/image-20210526173824650.png)



### 解释器和JIT

当虚拟机启动时候，**解释器可以首先发挥作用**，不用等待jit编译器全部编译完成再执行，这样可以省去许多不必要的编译时间。并且随着程序运行时间的推移，jit编译器逐渐发挥作用，根据热点探测功能，**将有价值的字节码编译为本地机器指令（热点代码），并缓存**，来得到更高的程序执行效率

  ![image-20210526192211499](../assert/image-20210526192211499.png)

### JIT

热点代码会触发JIT  （方法调用计数器和回边计数器）

<center>热点判断</center>

![image-20210526200023916](../assert/image-20210526200023916.png)





<center>方法调用计数器</center>



![image-20210526201001222](../assert/image-20210526201001222.png)

![image-20210526200154602](../assert/image-20210526200154602.png)



<center>回边计数器</center>

![image-20210526201235103](../assert/image-20210526201235103.png)

 ![image-20210526201332937](../assert/image-20210526201332937.png)





<center>热度衰减</center>

假如只数绝对次数，那么只要执行时间够久，所有代码都能成为热点代码，如何改善

![image-20210526200719439](../assert/image-20210526200719439.png)



<center><font size=10>c1 c2编译器</font></center>

![image-20210526201717181](../assert/image-20210526201717181.png)

![image-20210526201957771](../assert/image-20210526201957771.png)

<img src="../assert/image-20210526202123970.png" alt="image-20210526202123970" style="zoom:67%;" />

总结：

- 一般来讲，jit编译出来的机器码性能比解释器高
- C2编译器启动时长比C1编译器慢，系统稳定执行后，C2编译器速度远远快于C1编译器







## String table

![image-20210526105522633](../assert/image-20210526105522633.png)

s1: "a"放入常量池

s2:"b"放入常量池

s3:"ab"放入常量池  （编译优化，直接在编译阶段把”a“+"b"编译为"ab"）

s4: new Stringbuffer,用append方法拼接”a“ ”b“，最后toString，相当于重新new了一个String对象，放在堆中

s5:常量池已经有"ab" 直接引用

s6:尝试把s4（”ab“）放入常量池，常量池中已有"ab"，所以放入失败，直接返回常量池中对象给s6



s3==s4? :  s3是常量池中“ab”，s4是new的string对象，结果为false

s3==s5? : s3是常量池中“ab”，s5企图把"ab"放入常量池，但常量池已有，直接引用常量池中对象，所以结果为true

s3==s6? :  s3是常量池中“ab”;尝试试把s4（”ab“）放入常量池，常量池中已有"ab"，所以放入失败，直接返回常量池中对象给s6  ;所以为true



x1==x2?: 当前的话是new个x2，然后成功把x2放入常量池，然后x1直接引用常量池对象，结果为true

​				如果x2.intern();和String x1="cd"；交换位置  ，那么在String x1="cd"时把cd放入常量池，而x2.intern();由于常量池中已有cd，不会成功把x2放入常量池，所以x1==x2为false；



**jdk1.6和jdk1.8的intern的区别：**（String s6=s4.intern() 区别在于若常量池中没有，1.8会把s4放入池中，而1.6是复制一份放入池中，真正的s4没有入池）![image-20210526110735792](../assert/image-20210526110735792.png)

**总结：** 直接用String s=”xxx“ 是在常量池中放”xxx“ s引用指向这个池子；如果下次还有同样的”xxx“，那么不会重复入池；如果是String x=new String（”xxx“），那么是在堆中放一个新对象，和池子无关；string.intern（）尝试把string内容放入池子（jdk1.6和1.8有区别）；

string x=”xxx“+x1 其实是新建了一个stringbuilder然后append，最后tostring（tostring最后调用了一个newstring） 那么显然这个x也是一个堆中新对象**字符串拼接不一定都用stringbuilder，如果拼接符号左右两边都是字符串常量或者常量引用，则仍然使用编译器优化 即非stringBuilder  **

![image-20210526220528438](../assert/image-20210526220528438.png)



## 其他知识

### 机器码 指令 汇编

计算机只认识机器语言，机器语言可读性实在太差，所以发明了指令，把机器码中特定的0和1序列简化为对应指令（比如mov，inc）

![image-20210526173251584](../assert/image-20210526173251584.png)

指令可读性还是太差，所以发明了汇编语言

![image-20210526173347375](../assert/image-20210526173347375.png)

最后为了让人编程更方便 发明了高级语言

![image-20210526173412760](../assert/image-20210526173412760.png)

![image-20210526173458022](../assert/image-20210526173458022.png)

java中特有的字节码，执行引擎就是转译为可执行的指令

![image-20210526173733617](../assert/image-20210526173733617.png)